// Reaper pass: copies bots from scratchBuffer to botsBuffer using prefix sums

// L1: offset = 0, size = 64*64
// L2: offset = 64*64, size = 64
// L3: offset = 64*64 + 64, size = 1
const L2_OFFSET = 64 * 64;
const L3_OFFSET = L2_OFFSET + 64;

@group(0) @binding(0) var<storage, read> scratchBuffer: array<Bot>;
@group(0) @binding(1) var<storage, read_write> botsBuffer: array<Bot>;
@group(0) @binding(2) var<storage, read> prefixBuffer: array<u32>;
@group(0) @binding(3) var<storage, read_write> bot_brains: array<Brain>;
@group(0) @binding(4) var<storage, read_write> brain_free_list: array<u32>;
@group(0) @binding(5) var<storage, read_write> brain_free_list_counter: atomic<u32>;

var<workgroup> parent_brain_id: u32;
var<workgroup> child_brain_id: u32;
var<workgroup> dsb: u32;
var<workgroup> out_idx: u32;

// 1 bot per workgroup
@compute @workgroup_size(64) fn main(
  @builtin(local_invocation_id) local_id: vec3u,
  @builtin(workgroup_id) workgroup_id: vec3u
) {

  if (local_id.x == 0) {
    let newBotCount = prefixBuffer[L3_OFFSET + 0u]; // update with MAX_BOTS
    // clean up area where there will be no bots
    if (workgroup_id.x >= newBotCount) {
      botsBuffer[workgroup_id.x].die_stay_breed = 0;
    }

    // incoming bot work starts here
    let bot_id = workgroup_id.x;
    var bot = scratchBuffer[bot_id];
    dsb = bot.die_stay_breed;

    if (dsb == 0) { // Die
      // release brain slot
      let index = atomicAdd(&brain_free_list_counter, 1u);
      brain_free_list[index] = bot.brain_id;
    }

    if (dsb > 0) { // Stay alive
      if (bot_id > 0u) {
        out_idx += prefixBuffer[bot_id - 1u];
      }

      if (bot_id > 64u) {
        out_idx += prefixBuffer[(bot_id-1u) / 64u - 1 + L2_OFFSET];
      }

      if (bot_id > 64u * 64u) {
        out_idx += prefixBuffer[(bot_id-1u) / (64u * 64u) - 1 + L3_OFFSET];
      }

      if (out_idx < arrayLength(&botsBuffer)) {
        botsBuffer[out_idx] = bot;
      }
    }

    if (dsb == 2 && out_idx+1 < arrayLength(&botsBuffer)) { // Breed
      // reset parent age
      botsBuffer[out_idx].age = 0;
      
      // acquire new brain slot
      let brain_index = atomicSub(&brain_free_list_counter, 1u) - 1u;
      child_brain_id= brain_free_list[brain_index];
      parent_brain_id = bot.brain_id;

      // create child bot
      var new_bot: Bot = bot;
      new_bot.id = bot.id + 1000000u;
      new_bot.die_stay_breed = 1u;
      new_bot.age = 0;
      let position = bot.position + normalize(bot.direction) * .1;
      new_bot.position = vec2f(clamp(position.x, -.95, .95), clamp(position.y, -.95, .95));
      new_bot.brain_id = child_brain_id;
      new_bot.color = bot.color;
      new_bot.energy = 100;
      botsBuffer[out_idx + 1] = new_bot;
    }
  }

  workgroupBarrier();
  if (dsb == 2 && out_idx+1 < arrayLength(&botsBuffer)) {
    // all threads in workgroup do the brain copy
    let t_id = local_id.x;
    let w1_size = 16u * 32u;
    let w1_chunk_size = w1_size / 64u;
    var start = t_id * w1_chunk_size;
    for (var i = 0u; i < w1_chunk_size; i = i + 1u) {
        let idx = start + i;
        bot_brains[child_brain_id].W1[idx] = bot_brains[parent_brain_id].W1[idx];
    }
    let b1_size = 32u;
    if (t_id < 32u) {
      bot_brains[child_brain_id].B1[t_id] = bot_brains[parent_brain_id].B1[t_id];
    }
    let w2_size = 32u * 16u;
    let w2_chunk_size = w2_size / 64u;
    start = t_id * w2_chunk_size;
    for (var i = 0u; i < w2_chunk_size; i = i + 1u) {
        let idx = start + i;
        bot_brains[child_brain_id].W2[idx] = bot_brains[parent_brain_id].W2[idx];
    }
    let b2_size = 16u;
    if (t_id < 16u) {
      bot_brains[child_brain_id].B2[t_id] = bot_brains[parent_brain_id].B2[t_id];
    }
  }
}
