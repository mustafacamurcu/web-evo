@group(0) @binding(0) var<storage, read> bots: array<Bot>;
@group(0) @binding(1) var<storage, read_write> bot_senses: array<BotSenses>;
const N_RAYS = 8;
const FOV = 3.14159265 / 2.0; // 90 degrees
const RAY_FOV = FOV / f32(N_RAYS);
const VISION_DISTANCE = 0.1;

var<workgroup> thread_senses: array<BotSenses, 64>;

fn get_signed_angle(v1: vec2f, v2: vec2f) -> f32 {
    let cross_product = v1.x * v2.y - v1.y * v2.x;
    let dot_product = dot(v1, v2);

    return atan2(cross_product, dot_product);
}

// 1 workgroup per bot
@compute @workgroup_size(64) fn main(
	@builtin(local_invocation_id) local_id: vec3u,
	@builtin(workgroup_id) workgroup_id: vec3u,
	@builtin(num_workgroups) num_workgroups: vec3u
) {
	let bot_id = workgroup_id.x;
	let num_bots = num_workgroups.x;

	// Each threads owns 1/64 of the bots
	// Finds the closest bot for each ray
	// so keeps track of 8 closest bots, one per ray
	// at the end we reduce within the ray to find the closest bot

	let bots_per_thread = (num_bots + 63u) / 64u;
	let bots_begin = local_id.x * bots_per_thread;
	let bots_end = min(bots_begin + bots_per_thread, num_bots);
	let t_id = local_id.x;
	let bot_dir = normalize(bots[bot_id].velocity);

	// Initialize thread senses
	for (var i = 0u; i < N_RAYS; i = i + 1u) {
		thread_senses[t_id].senses[i] = BotSense(0u, VISION_DISTANCE); // No bot, max distance
	}

	// Each threads looks through their subset of bots
	for (var i = bots_begin; i < bots_end; i = i + 1u) {
		if (i == bot_id) {
			continue;
		}
		let to_other = bots[i].position - bots[bot_id].position;
		let dist = length(to_other);
		if (dist > VISION_DISTANCE) {
			continue; // Too far
		}
		let to_other_dir = normalize(to_other);
		let angle = get_signed_angle(bot_dir, to_other_dir);
		if (angle < -FOV/2.0 || angle > FOV/2.0) {
			continue; // Out of this fov
		}
		// Within fov and distance
		var ray_id = u32((angle + FOV/2.0) / RAY_FOV);
		if (dist < thread_senses[t_id].senses[ray_id].distance) {
			thread_senses[t_id].senses[ray_id] = BotSense(1u, dist); // Found closer bot
		}
	}

	// Each thread found found candidates from their subset of bots
	workgroupBarrier();

	// 8 threads find the best candidate for their ray
	if (t_id < N_RAYS) {
		let ray_id = t_id;
		var min_ray: BotSense = thread_senses[0u].senses[ray_id];
		for(var i = 1u; i < 64u; i = i + 1u) {
			if (thread_senses[i].senses[ray_id].distance < min_ray.distance) {
				min_ray = thread_senses[i].senses[ray_id];
			}
		}
		bot_senses[bot_id].senses[ray_id] = min_ray;
	}
}