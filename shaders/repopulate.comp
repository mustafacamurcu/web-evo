@group(0) @binding(0) var<storage, read_write> num_bots: array<u32,8>;
@group(0) @binding(1) var<storage, read_write> botsBuffer: array<Bot>;
@group(0) @binding(2) var<storage, read_write> bot_brains: array<Brain>;
@group(0) @binding(3) var<storage, read_write> brain_free_list: array<u32>;
@group(0) @binding(4) var<storage, read_write> brain_free_list_counter: atomic<u32>;

var<workgroup> new_brain_id: u32;
var<workgroup> parent_brain_id: u32;

const BOT_INITIAL_ENERGY = %BOT_INITIAL_ENERGY%;

// 1 workgroup only
@compute @workgroup_size(64) fn main(
  @builtin(local_invocation_id) local_id: vec3u,
  @builtin(workgroup_id) workgroup_id: vec3u,
	@builtin(num_workgroups) num_workgroups: vec3u
) {
	let bot_count = num_bots[0];
	let t_id = local_id.x;
	if (bot_count >= 100u) {
		return; // already at max population
	}

	if (t_id == 0u) {
		// Update bot count to double it
		num_bots[0] = bot_count+1u;
		// Get a brain slot for the new bot
		let index = atomicSub(&brain_free_list_counter, 1u) -1u;
		new_brain_id = brain_free_list[index];
		// pick a random parent bot to copy brain from
		// find the oldest bot
		var max_age = 0u;
		var max_age_index = 0u;
		for (var i = 0u; i < bot_count; i = i + 1u) {
			let age = botsBuffer[i].age;
			if (age > max_age) {
				max_age = age;
				max_age_index = i;
			}
		}
		
		let parent_bot_index = max_age_index;
		let bot = botsBuffer[parent_bot_index];
		parent_brain_id = bot.brain_id;
		var new_bot: Bot = bot;
		new_bot.id = bot.id + 99900000u;
		new_bot.die_stay_breed = 1u;
		new_bot.age = 0;
		let position =  rv2(bot.position+bot.direction+fract(f32(bot.age)/173.3)) * 2.0 - 1.0;
		new_bot.direction = normalize(rv2(bot.position-bot.direction+fract(f32(bot.age)/737.2)));
		new_bot.position =  position;
		new_bot.brain_id = new_brain_id;
		new_bot.color = bot.color;
		new_bot.energy = BOT_INITIAL_ENERGY;
		botsBuffer[bot_count] = new_bot;
	}

	// all threads in workgroup do the brain copy
	let w1_size = 16u * 32u;
	let w1_chunk_size = w1_size / 64u;
	var start = t_id * w1_chunk_size;
	for (var i = 0u; i < w1_chunk_size; i = i + 1u) {
			let idx = start + i;
			let seed = bot_brains[parent_brain_id].W1[idx];
			bot_brains[new_brain_id].W1[idx] = seed;
	}
	let b1_size = 32u;
	if (t_id < 32u) {
		let seed = bot_brains[parent_brain_id].B1[t_id];
		bot_brains[new_brain_id].B1[t_id] = seed;
	}
	let w2_size = 32u * 16u;
	let w2_chunk_size = w2_size / 64u;
	start = t_id * w2_chunk_size;
	for (var i = 0u; i < w2_chunk_size; i = i + 1u) {
			let idx = start + i;
		let seed = bot_brains[parent_brain_id].W2[idx];
			bot_brains[new_brain_id].W2[idx] = seed;
	}
	let b2_size = 16u;
	if (t_id < 16u) {
		let seed = bot_brains[parent_brain_id].B2[t_id];
		bot_brains[new_brain_id].B2[t_id] = seed;
	}
	
}