@group(0) @binding(0) var<storage, read_write> bot_brains: array<Brain>;
@group(0) @binding(1) var<storage, read> bot_senses: array<BotSenses>;
@group(0) @binding(2) var<storage, read_write> bots: array<Bot>; 

// Brain
var<workgroup> w1: array<f32, 16 * 32>;
var<workgroup> b1: array<f32, 32>;
var<workgroup> w2: array<f32, 32 * 16>;
var<workgroup> b2: array<f32, 16>;

// Intermediate calculations
var<workgroup> input_layer: array<f32, 16>;
var<workgroup> multiplied_w1: array<f32, 32>;
var<workgroup> added_b1: array<f32, 32>;
var<workgroup> multiplied_w2: array<f32, 16>;
var<workgroup> added_b2: array<f32, 16>;

// 1 workgroup per bot
@compute @workgroup_size(64) fn main(
	@builtin(local_invocation_id) local_id: vec3u,
	@builtin(workgroup_id) workgroup_id: vec3u
) {
	let bot_id = workgroup_id.x;
	let brain_id = bots[bot_id].brain_id;
	let t_id = local_id.x;

	// Load brain into shared memory
	let w1_size = 16u * 32u;
	let w1_chunk_size = w1_size / 64u;
	if (t_id < 64u) {
		let start = t_id * w1_chunk_size;
		for (var i = 0u; i < w1_chunk_size; i = i + 1u) {
		    let idx = start + i;
		    w1[idx] = bot_brains[brain_id].W1[idx];
		}
	}

	let b1_size = 32u;
	if (t_id < 32u) {
		b1[t_id] = bot_brains[brain_id].B1[t_id];
	}

	let w2_size = 32u * 16u;
	let w2_chunk_size = w2_size / 64u;
	if (t_id < 64u) {
		let start = t_id * w2_chunk_size;
		for (var i = 0u; i < w2_chunk_size; i = i + 1u) {
		    let idx = start + i;
		    w2[idx] = bot_brains[brain_id].W2[idx];
		}
	}

	let b2_size = 16u;
	if (t_id < 16u) {
		b2[t_id] = bot_brains[brain_id].B2[t_id];
	}

	// Load bot senses into shared memory
	if (t_id < 8u) {
		input_layer[t_id*2] = bot_senses[bot_id].senses[t_id].distance;
		if (bot_senses[bot_id].senses[t_id].type_id != 0u) {
			input_layer[t_id*2+1] = 1.0; // Sees
		} else {
			input_layer[t_id*2+1] = 0.0; // Doesn't see
		}
	}

	workgroupBarrier();

	// multiply input_layer (16) with w1 (16*32)
	if (t_id < 32u) {
		var sum = 0.0;
		for (var i = 0u; i < 16u; i = i + 1u) {
			sum += input_layer[i] * w1[i * 32u + t_id];
		}
		multiplied_w1[t_id] = sum;
	}

	workgroupBarrier();

	// add b1 (32)
	if (t_id < 32u) {
		added_b1[t_id] = multiplied_w1[t_id] + b1[t_id];
		// relu
		if (added_b1[t_id] < 0.0) {
			added_b1[t_id] = 0.0;
		}
	}

	workgroupBarrier();

	// multiply added_b1 (32) with w2 (32*16)
	if (t_id < 16u) {
		var sum = 0.0;
		for (var i = 0u; i < 32u; i = i + 1u) {
			sum += added_b1[i] * w2[i * 16u + t_id];
		}
		multiplied_w2[t_id] = sum;
	}

	workgroupBarrier();

	// add b2 (16)
	if (t_id < 16u) {
		added_b2[t_id] = multiplied_w2[t_id] + b2[t_id];
		// relu
		if (added_b2[t_id] < 0.0) {
			added_b2[t_id] = 0.0;
		}
	}

	workgroupBarrier();

	// final decisions
	if (t_id == 0u) {
		var mx = added_b2[0];
		var max_index = 0u;
    for (var i = 1u; i < 32u; i++) {
        let cur = added_b2[i];
        if (cur > mx) {
            mx = cur;
            max_index = i;
        }
    }
		bots[bot_id].decision = max_index;
	}

	workgroupBarrier();

	// mutate brain
	// get random index based on position
	let pos = bots[bot_id].position;
	let index_seed = pos.x*100 - floor(pos.x)*100 + pos.y*100 - floor(pos.y)*100;
	let normalized_index_seed = index_seed - floor(index_seed);
	let random_index = u32(normalized_index_seed * f32(w1_size + b1_size + w2_size + b2_size) * 100); // *100 to decrease chance of mutation

	// get random value
	let value_seed = pos.x*1000 - floor(pos.x)*1000 + pos.y*1000 - floor(pos.y)*1000;
	let normalized_value_seed = value_seed - floor(value_seed);
	let random_value = (normalized_value_seed - 0.5); // small change between -0.05 and 0.05
	
	if (random_index < w1_size) {
		bot_brains[brain_id].W1[random_index] = random_value;
	} else if (random_index < w1_size + b1_size) {
		bot_brains[brain_id].B1[random_index - w1_size] = random_value;
	} else if (random_index < w1_size + b1_size + w2_size) {
		bot_brains[brain_id].W2[random_index - w1_size - b1_size] = random_value;
	} else if (random_index < w1_size + b1_size + w2_size + b2_size) {
		bot_brains[brain_id].B2[random_index - w1_size - b1_size - w2_size] = random_value;
	}
}