const L1 = 16;
const L2 = 32;
const L3 = 16;

// struct Brain {
// 	W1: array<f32, L1*L2>,
// 	B1: array<f32, L2>,
// 	W2: array<f32, L2*L3>,
// 	B2: array<f32, L3>,
// }

@group(0) @binding(0) var<storage, read> in_bots: array<Bot>;
@group(0) @binding(1) var<storage, read_write> out_bots: array<Bot>;
@group(0) @binding(2) var<storage, read> foods: array<vec2f>;
@group(0) @binding(3) var<storage, read> spikes: array<vec2f>;
// @group(0) @binding(4) var<storage, read_write> brains: array<Brain>;

@compute @workgroup_size(64) fn main(
	@builtin(global_invocation_id) id: vec3u,
	@builtin(num_workgroups) counts: vec3u
) {
	let count = counts.x*64;

	// Use threads for MatMul
	// Each workgroup handles one bot
	// 64 Threads split the work of calculating the brain
	// There are N steps of calculation
	// 1. Input + B1 (16)
	// 2. * W1 (16*32)
	// 3. + B2 (32)
	// 4. * W2 (32*16)
	// Each step of calculation is split across the 64 threads
	// At the end of each step, sync threads using workgroupBarrier()
	// Use shared memory to store intermediate results
	// shared memory size is at least 8KB usually, should fit


	out_bots[id.x].energy = in_bots[id.x].energy;
	for (var i: u32 = 0; i < 100; i = i + 1) {
		// distance to food
		if (length(foods[i] - in_bots[id.x].position) < 0.02) {
			out_bots[id.x].energy = out_bots[id.x].energy + 0.1;
		}
	}

	for (var i: u32 = 0; i < 100; i = i + 1) {
		// distance to spikes
		if (length(spikes[i] - in_bots[id.x].position) < 0.02) {
			out_bots[id.x].energy = out_bots[id.x].energy - 0.1;
		}
	}

	out_bots[id.x].velocity = normalize(out_bots[id.x].velocity) * 0.00001;
	out_bots[id.x].position = in_bots[id.x].position + in_bots[id.x].velocity;

	// Bounce off walls
	if (out_bots[id.x].position.x < -1.0 || out_bots[id.x].position.x > 1.0) {
		out_bots[id.x].velocity.x = -out_bots[id.x].velocity.x;
	}
	if (out_bots[id.x].position.y < -1.0 || out_bots[id.x].position.y > 1.0) {
		out_bots[id.x].velocity.y = -out_bots[id.x].velocity.y;
	}
}